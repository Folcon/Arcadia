(ns arcadia.data
  (:require [arcadia.internal.namespace])
  (:import [System.Reflection
            FieldInfo
            ConstructorInfo
            BindingFlags
            ParameterInfo]
           [System TimeSpan]
           [System.Reflection Assembly]))

;; 

;; ============================================================
;; utils

;; slightly faster:
(defmacro ^:private lit-str [& xs]
  `(str
     (doto (new StringBuilder)
       ~@(for [x xs]
           (if (string? x)
             `(.Append ~x)
             `(.Append (str ~x)))))))

;; ============================================================
;; object database 
;; ============================================================

;; TODO where should this lift? 
;; TODO is the atom needed?
(defonce ^:dynamic *object-db* (atom {}))

;; this never drains - memory leak.
(defn db-put [^UnityEngine.Object obj]
  (let [id (.GetInstanceID obj)]
    (swap! *object-db* assoc id obj)
    id))

(defn clean-object-db
  "Remove all destroyed objects from `*object-db*`."
  []
  (swap! *object-db*
    (fn [db]
      (persistent!
        (reduce-kv
          (fn [acc id obj]
            (if (nil? (Arcadia.Util/TrueNil obj))
              (dissoc! acc id)
              acc))
          (transient db)
          db)))))

;; TODO handle nil
;; clojure errors out if this returns nil
;; considers the dispatch to have failed... 
(defn db-get [id]
  (if (contains? @*object-db* id)
    (get @*object-db* id)
    (throw
      (InvalidOperationException.
        (str "Attempting to retrieve an object corresponding to " id " from `*object-db*`, but no such object has been registered.")))))

;; ============================================================
;; installation
;; ============================================================

(defn- install-reader [name var]
  (assert (symbol? name))
  (assert (var? var))
  (alter-var-root #'clojure.core/*data-readers* assoc name var)
  ;; for the repl (bit aggressive):
  (when (.getThreadBinding ^clojure.lang.Var #'clojure.core/*data-readers*)
    (set! clojure.core/*data-readers*
      (merge clojure.core/*data-readers*
        (.getRawRoot #'clojure.core/*data-readers*)))))

;; ============================================================
;; constructor wrangling
;; ============================================================

(def
  ^{:doc "Vector of all private and public instance FieldInfos of type
 sorted by name"}
  sorted-fields
  (memoize ; speeds up instance-from-values by about 1/3
    (fn sorted-fields [type]
      (->> (.GetFields type
             (enum-or BindingFlags/Public BindingFlags/NonPublic BindingFlags/Instance))
           (sort-by #(.Name ^FieldInfo %))
           vec))))

(def keyed-fields
  (memoize
    (fn keyed-fields [type]
      (let [fs (.GetFields type
                 (enum-or BindingFlags/Public BindingFlags/NonPublic BindingFlags/Instance))]
        (zipmap
          (map #(keyword (.Name ^FieldInfo %)) fs)
          fs)))))

(defn field-values
  "Vector of values of all private and public instance fields of obj
   sorted by the names of the field"
  [obj]
  (let [type (.GetType obj)
        fields (sorted-fields type)]
    (mapv #(.GetValue ^FieldInfo % obj) fields)))

(def resolve-serialized-type
  (memoize
    (fn resolve-serialized-type [st]
      (let [s (symbol (str "UnityEngine." st))
            t (resolve s)]
        (or t
            (throw
              (ArgumentException.
                (str "Symbol " s " does not resolve."))))))))

(defn instance-from-values
  "Create an instance of type from the values vector, assumed
  to be sorted by the name of the fields (as generated by field-values)"
  [type values]
  (let [type (resolve-serialized-type type) ; bad that we have to do this, find root problem upstream
        obj (Activator/CreateInstance type)
        fields (sorted-fields type)]
    (arcadia.debug/break)
    (loop [i (int 0)]
      (when (< i (count fields))
        (let [^FieldInfo field (nth fields i)
              val (nth values i)]
          (.SetValue field obj
            (Convert/ChangeType
              val
              (.FieldType field)))
          (recur (inc i)))))
    obj))

(defn instance-from-values-map
  [{:keys [::type] :as values}]
  (let [type (resolve-serialized-type type)
        obj (Activator/CreateInstance type)
        fields (keyed-fields type)]
    (reduce-kv
      (fn [_ k v]
        (when-not (= ::type k)
          (if-let [^FieldInfo field (get fields k)]
            (.SetValue field obj
              (Convert/ChangeType v (.FieldType field)))
            (throw
              (ArgumentException.
                (str "No corresponding field found in " type " for field key " k))))))
      nil
      values)
    obj))

;; ============================================================
;; experimental direct method on Vector3 (for timing)
;; ============================================================

;; result: looks like we can speed things up by a fair amount by
;; using direct setting rather than reflection

;; (def counter (atom 0))

;; (defn deserialize-v3 [[x y z :as stuff]]
;;   ;; (swap! counter inc)
;;   ;; (println "args:" stuff)
;;   (UnityEngine.Vector3. x y z))

;; (defonce old-v3-deserialize
;;   (get clojure.core/*data-readers* 'unity/Vector3))

;; (alter-var-root #'clojure.core/*data-readers*
;;   assoc
;;   'unity/Vector3
;;   #'deserialize-v3)

;; (set! clojure.core/*data-readers* (.getRawRoot #'clojure.core/*data-readers*))


;; ============================================================
;; value types
;; ============================================================

(defn type-symbol [t]
  (cond (symbol? t) t
        (isa? (type t) Type) (let [^Type t t] (symbol (.FullName t)))
        :else (throw (Exception. (str t " is not a type or a symbol")))))

(defn- obsolete? [t]
  (some #(instance? ObsoleteAttribute %) (.GetCustomAttributes t false)))

(def value-types
  (->> UnityEngine.Vector3
       .Assembly
       .GetTypes
       (filter #(.IsValueType ^Type %))
       (filter #(.IsVisible ^Type %))
       (filter #(= "UnityEngine" (.Namespace ^Type %)))
       (remove obsolete?)
       (remove #(.IsEnum ^Type %))
       (remove #(.IsNested ^Type %))))

;; (defn parser-for-value-type [^Type t]
;;   `(defn ~(symbol (str "parse-" (.Name t))) [params#]
;;      (instance-from-values
;;        ~(-> t .FullName symbol)
;;        params#)))

;; (defn value-type-print-dup-impl [obj ^System.IO.TextWriter stream]
;;   (let [type (.GetType obj)
;;         type-name (symbol (.FullName type))]
;;     (.Write stream
;;             (str "#=(arcadia.data/instance-from-values "
;;                  type-name
;;                  " "
;;                  (field-values obj)
;;                  ")"))))

;; (defn install-value-type-print-dup [^Type t]
;;   (.addMethod ^clojure.lang.MultiFn print-dup t value-type-print-dup-impl))

;; (defn value-type-print-method-impl [obj ^System.IO.TextWriter w]
;;   (let [type (.GetType obj)]
;;     (.Write w
;;             (str "#unity/" (.Name type) " "
;;                  (field-values obj)))))

;; (defn install-value-type-print-method [^Type t]
;;   (.addMethod ^clojure.lang.MultiFn print-method t value-type-print-method-impl))

;; (defn install-parser-for-value-type [^Type type]
;;   `(alter-var-root
;;      (var clojure.core/*data-readers*)
;;      assoc
;;      (quote ~(symbol (str "unity/" (.Name type))))
;;      (var ~(symbol (str "arcadia.data/parse-" (.Name type))))))


;; (defmacro ^:private value-type-stuff []
;;   (cons `do
;;     (for [t value-types]
;;       (list `do
;;         (parser-for-value-type t)
;;         (install-parser-for-value-type t)))))

;; (value-type-stuff)

;; (doseq [t value-types]
;;   (install-value-type-print-method t)
;;   (install-value-type-print-dup t))



;; ------------------------------------------------------------
;; print things

(defn default-unity-print [x ^System.IO.TextWriter w]
  (.Write w
    (lit-str "#<" (class x) " " x ">")))

;; don't want to mutate the global hierarchy for this
(doseq [t value-types]
  (.addMethod ^clojure.lang.MultiFn print-method t default-unity-print))

;; ------------------------------------------------------------
;; print value types with *print-dup*

(defn value-type-print-dup-vec [x ^System.IO.TextWriter w]
  (let [sb (new StringBuilder "#unity/value")
        t (class x)
        fs (sorted-fields t)]
    (doto sb
      (.Append "[\"")
      (.Append (.Name t))
      (.Append "\""))
    (loop [i (int 0)]
      (when (< i (count fs))
        (let [^FieldInfo f (nth fs i)]
          (.Append sb ",")
          (.Append sb (str (.GetValue f x)))
          (recur (inc i)))))
    (.Append sb "]")
    (.Write w (str sb))))

(defn value-type-print-dup-map [x ^System.IO.TextWriter w]
  (let [t (class x)
        fs (sorted-fields t)
        ^StringBuilder sb (new StringBuilder "#unity/value")]
    (doto sb
      (.Append "{:arcadia.data/type \"")
      (.Append (.Name t))
      (.Append "\""))
    (.Write w
      (loop [i (int 0)]
        (if (< i (count fs))
          (let [^FieldInfo f (nth fs i)]
            (.Append sb ",")
            (doto sb
              (.Append ":")
              (.Append (.Name f))
              (.Append " ")
              (.Append (.GetValue f x)))
            (recur (inc i)))
          (do (.Append sb "}")
              (str sb)))))))

(defn value-type-print-dup [x w]
  (if *print-readably*
    (value-type-print-dup-map x w)
    (value-type-print-dup-vec x w)))

;; we don't want to mutate the global hierarchy for this
(doseq [t value-types]
  (.addMethod ^clojure.lang.MultiFn print-dup t value-type-print-dup))

;; ------------------------------------------------------------
;; custom interventions

;; (defmethod print-dup UnityEngine.Vector3 [v ^System.IO.TextWriter w]
;;   (let [^UnityEngine.Vector3 v v]
;;     (.Write w
;;       (lit-str "#unity/Vector3[" (.x v) " " (.y v) " " (.z v) "]"))))

;; ============================================================
;; read value types printed with *print-dup* back

(defonce parse-value-type-hierarchy (atom (make-hierarchy)))

;; We need to do this because `derive` doesn't work with strings.
;; Don't want to memoize it because that might enable attacks on
;; memory for certain edn strings.
(defonce value-type-string->type
  (atom
    (persistent!
      (reduce
        (fn [acc ^Type t]
          (assoc! acc (.Name t) t))
        (transient {})
        value-types))))

(defn parse-value-type-dispatch [args]
  (get @value-type-string->type
    (cond
      (vector? args)
      (nth args 0)
      
      (map? args)
      (get args ::type)

      :else (throw
              (ArgumentException.
                (str "Expects vector or map, instead got " (class args)))))))

;; install the dispatch function itself rather than a reference to it
;; when we're confident
(defmulti parse-value-type #'parse-value-type-dispatch
  :hierarchy parse-value-type-hierarchy)

(swap! parse-value-type-hierarchy
  (fn [h]
    (letfn [(rfn [h, ^System.Type t]
              (derive h t ::value-type))]
      (reduce rfn h value-types))))

(defmethod parse-value-type ::value-type [args]
  (cond
    (vector? args)
    (instance-from-values (nth args 0) (subvec args 1))

    (map? args)
    (instance-from-values-map args)

    :else (throw
            (ArgumentException.
              (str "Expects vector or map, instead got " (class args))))))

(install-reader 'unity/value #'parse-value-type)

;; ============================================================
;; object types
;; ============================================================

;; (def object-types
;;   (->> UnityEngine.GameObject
;;        .Assembly
;;        .GetTypes
;;        (filter #(isa? % UnityEngine.Object))))

;; (defn parse-object [id]
;;   (or (db-get id)
;;       (do
;;         (UnityEngine.Debug/Log (str "Cant find object with ID " id))
;;         (UnityEngine.Object.))))



;; (defmethod print-method
;;   UnityEngine.Object [^UnityEngine.Object v ^System.IO.TextWriter w]
;;   (.Write w (str "#unity/" (.. v GetType Name) " "(db-put v))))

;; (defn install-parser-for-object-type [^Type type]
;;   `(alter-var-root
;;      (var clojure.core/*data-readers*)
;;      assoc
;;      (quote ~(symbol (str "unity/" (.Name type))))
;;      (var ~(symbol (str "arcadia.data/parse-object")))))

;; (defmacro ^:private object-type-stuff []
;;   (cons `do
;;     (for [t object-types]
;;       (list `do
;;         ;; object types share the same parser
;;         (install-parser-for-object-type t)))))

;; (object-type-stuff)

(defmethod print-method UnityEngine.Object [^UnityEngine.Object x, ^System.IO.TextWriter stream]
  (.Write stream
    (lit-str "#<" x ">")))

(defmethod print-dup UnityEngine.Object [^UnityEngine.Object v ^System.IO.TextWriter w]
  (.Write w
    (lit-str "#unity/object[" (class v) " " (db-put v) "]")
    ;; (str "#=(arcadia.data/db-get " (db-put v) ")")
    ))

(defn parse-object [[_ id]]
  (db-get id))

(install-reader 'unity/object #'parse-object)

;; (defmethod print-dup UnityEngine.Object [^UnityEngine.Object x, ^System.IO.TextWriter stream]
;;   )

;; AnimationCurves are different
;; finish
;; (comment 
;;   (defmethod print-dup
;;     UnityEngine.AnimationCurve [ac stream]
;;     (.Write stream
;;             (str "#=(UnityEngine.AnimationCurve. "
;;                  "(into-array ["
;;                  (apply str 
;;                         (->> ac
;;                              .keys
;;                              (map #(str "(UnityEngine.Keyframe. "
;;                                         (.time %)
;;                                         (.value %)
;;                                         (.inTangent %)
;;                                         (.outTangent %)
;;                                         ")"))
;;                              (interleave (repeat " "))))
;;                  ")")))
;;   (defmethod print-method
;;     UnityEngine.AnimationCurve [ac w]
;;     (.Write w
;;             (str "#unity/AnimationCurve"
;;                  (.GetInstanceID ~v))))
  
;;   (defn parse-AnimationCurve [v]
;;     (new UnityEngine.AnimationCurve (into-array (map eval (first v)))))
  
;;   (alter-var-root
;;     #'clojure.core/*data-readers*
;;     assoc
;;     'unity/AnimationCurve
;;     #'arcadia.data/parse-AnimationCurve))

;; ============================================================
;; for value types:



;; ============================================================
;; for defmutable:

(defn- parse-user-type-dispatch [{:keys [::type]}]
  type)

(defmulti parse-user-type
  "This multimethod should be considered an internal, unstable
  implementation detail for now. Please refrain from extending it."
  parse-user-type-dispatch
  :default ::default)

(defmethod parse-user-type ::default [{t ::type
                                       :as spec}]
  (cond
    (nil? t)
    (throw
      (Exception. "No value found for key `::arcadia.data/type`"))
    
    (not (symbol? t))
    (throw
      (Exception. (str "Value for key `::arcadia.data/type` must be a symbol, instead got " (class t)))))
  (let [ns-name (-> (clojure.string/join "."
                      (butlast
                        (clojure.string/split (name t) #"\." )))
                    (clojure.string/replace "_" "-")
                    symbol)]
    (arcadia.internal.namespace/quickquire ns-name)
    (if (contains? (methods parse-user-type) (parse-user-type-dispatch spec))
      (parse-user-type spec)
      (throw
        (Exception.
          (str
            "`arcadia.data/parse-user-type` multimethod extension cannot be found for `::arcadia.data/type` value " t))))))

(install-reader 'arcadia.data/data #'parse-user-type)
